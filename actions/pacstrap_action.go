/*
Pacstrap Action

Construct the target rootfs with pacstrap tool.

Yaml syntax:
 - action: pacstrap
   mirror: <url with placeholders>
   repositories: <list of repositories>

Mandatory properties:

 - mirror -- the full url for the repository, with placeholders for
   $arch and $repo as needed, as would be found in mirrorlist

Optional properties:
 - repositories -- list of repositories to use for packages selection.
   Properties for repositories are described below.

Yaml syntax for repositories:

 repositories:
   - name: repository name
     siglevel: signature checking settings (optional)
*/
package actions

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/go-debos/debos"
)

const configOptionSection = `
[options]
GPGDir   = %[1]s/etc/pacman.d/gnupg/
HoldPkg  = pacman glibc
Architecture = auto
SigLevel = Required DatabaseOptional TrustedOnly
`

const configRepoSection = `

[%[1]s]
Include = %[2]s
`

const mirrorListTemplate = `
# Mirror list generated by pacstrap action of debos

Server = %s
`

type Repository struct {
	Name     string
	SigLevel string
}

type PacstrapAction struct {
	debos.BaseAction `yaml:",inline"`
	Mirror           string
	Repositories     []Repository
	ImportedKeyrings []string `yaml:"imported-keyrings"`
}

func NewPacstrapAction() *PacstrapAction {
	d := PacstrapAction{}

	// Note there is no default mirror
	// TODO: Make the mirror URL optional by using reflector (when
	//       present) to generate the mirrorlist
	d.Repositories = []Repository{
		Repository{Name: "core"}, Repository{Name: "extra"}, Repository{Name: "community"}}

	return &d
}

func (d *PacstrapAction) writeRepos(f io.Writer, mirrorListPath string) error {
	for _, r := range d.Repositories {
		if _, err := io.WriteString(f, fmt.Sprintf(configRepoSection, r.Name, mirrorListPath)); err != nil {
			return err
		}
		if r.SigLevel != "" {
			if _, err := io.WriteString(f, fmt.Sprintf("SigLevel = %s\n", r.SigLevel)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (d *PacstrapAction) writePacmanConfig(context *debos.DebosContext, configPath, mirrorListPath string) error {
	f, err := os.OpenFile(configPath, os.O_RDWR|os.O_CREATE, 0644)
	if err != nil {
		return fmt.Errorf("Couldn't open pacman config: %v", err)
	}
	defer func() {
		f.Close()
		if err != nil {
			os.Remove(configPath)
		}
	}()

	if _, err = f.WriteString(fmt.Sprintf(configOptionSection, context.Rootdir)); err != nil {
		return fmt.Errorf("Couldn't write pacman config: %v", err)
	}
	if err = d.writeRepos(f, mirrorListPath); err != nil {
		return fmt.Errorf("Couldn't write pacman config: %v", err)
	}
	return nil
}

func (d *PacstrapAction) writeMirrorList(context *debos.DebosContext, mirrorListPath string) error {
	if err := os.MkdirAll(path.Dir(mirrorListPath), 0755); err != nil {
		return fmt.Errorf("Unable to make directory for mirror list: %v", err)
	}

	f, err := os.OpenFile(mirrorListPath, os.O_RDWR|os.O_CREATE, 0644)
	if err != nil {
		return fmt.Errorf("Couldn't open mirror list: %v", err)
	}
	defer func() {
		f.Close()
		if err != nil {
			os.Remove(mirrorListPath)
		}
	}()

	if _, err = f.WriteString(fmt.Sprintf(mirrorListTemplate, d.Mirror)); err != nil {
		return fmt.Errorf("Couldn't write to mirror list: %v", err)
	}
	return nil
}

func (d *PacstrapAction) findHostKeyrings(context *debos.DebosContext) ([]string, error) {
	const root = "/usr/share/pacman/keyrings"
	keyrings := make([]string, 0)
	findKeyrings := func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}
		if strings.HasSuffix(path, ".gpg") {
			keyrings = append(keyrings, path)
		}
		return nil
	}
	if _, err := os.Stat(root); err != nil {
		if !os.IsNotExist(err) {
			return nil, err
		}
	} else if err := filepath.Walk(root, findKeyrings); err != nil {
		return nil, err
	}

	return keyrings, nil
}

func (d *PacstrapAction) createTrustDb(context *debos.DebosContext, configPath string, importedKeyrings []string) error {
	trustdir := filepath.Join(context.Scratchdir, "pacman-keyrings")
	if err := os.MkdirAll(trustdir, 0755); err != nil {
		return err
	}

	for _, importedKeyring := range importedKeyrings {
		key := debos.CleanPathAt(importedKeyring, context.RecipeDir)
		keybase := strings.TrimSuffix(key, ".gpg")
		trustfile := keybase + "-trusted"
		revokedfile := keybase + "-revoked"

		if err := debos.CopyFile(key, filepath.Join(trustdir, filepath.Base(keybase+".gpg")), 0644); err != nil {
			return err
		}

		if _, err := os.Stat(trustfile); err == nil {
			if err := debos.CopyFile(trustfile, filepath.Join(trustdir, filepath.Base(trustfile)), 0644); err != nil {
				return err
			}
		} else if !os.IsNotExist(err) {
			return err
		}
		if _, err := os.Stat(revokedfile); err == nil {
			if err := debos.CopyFile(revokedfile, filepath.Join(trustdir, filepath.Base(revokedfile)), 0644); err != nil {
				return err
			}
		} else if !os.IsNotExist(err) {
			return err
		}
	}

	// pacman has a hard-coded directory from which it will build
	// the trustdb, which is /usr/share/pacman/keyrings
	cmd := debos.Command{}
	cmd.AddBindMount(trustdir, "/usr/share/pacman/keyrings")
	cmdline := []string{
		"pacman-key", "--nocolor", "--config", configPath, "--populate"}
	if err := cmd.Run("Pacman-key", cmdline...); err != nil {
		return fmt.Errorf("Couldn't populate pacman trusted keys: %v", err)
	}

	return nil
}

func (d *PacstrapAction) processPacmanConf(context *debos.DebosContext, conffile string) error {
	f, err := os.OpenFile(conffile, os.O_RDWR, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	var out bytes.Buffer

	scanner := bufio.NewScanner(f)
	commenting := false
	for scanner.Scan() {
		text := scanner.Text()
		s := strings.ToLower(strings.TrimSpace(text))
		if strings.HasPrefix(s, "[") {
			commenting = !strings.HasPrefix(s, "[options]")
		}
		if commenting {
			out.WriteString("# ")
		}
		out.WriteString(text)
		out.WriteString("\n")
	}

	out.WriteString("\n###  Begin debos generated repository configuration\n\n")
	if err := d.writeRepos(&out, "/etc/pacman.d/mirrorlist"); err != nil {
		return err
	}

	whence := 0
	if _, err := f.Seek(0, whence); err != nil {
		return err
	}
	if err := f.Truncate(0); err != nil {
		return err
	}
	if _, err := out.WriteTo(f); err != nil {
		return err
	}
	return nil
}

func (d *PacstrapAction) Run(context *debos.DebosContext) error {
	d.LogStart()

	if d.Mirror == "" {
		return fmt.Errorf("No mirror set, aborting.")
	}
	if len(d.Repositories) == 0 {
		return fmt.Errorf("No repositories configured.")
	}

	configPath := path.Join(context.Scratchdir, "pacman.conf")
	mirrorListPath := path.Join(context.Rootdir, "/etc/pacman.d/mirrorlist")

	// Create config for pacstrap
	if err := d.writePacmanConfig(context, configPath, mirrorListPath); err != nil {
		return err
	}

	// Mirror list for pacstrap
	if err := d.writeMirrorList(context, mirrorListPath); err != nil {
		return err
	}

	// Run pacman-key
	// Note that the host's pacman/gnupg secrets are root-only,
	// and we want to avoid running fakemachine/debos as root. As
	// such, explicitly run pacman-key --init so that new set is
	// generated.
	cmdline := []string{"pacman-key", "--nocolor", "--config", configPath, "--init"}
	if err := (debos.Command{}.Run("Pacman-key", cmdline...)); err != nil {
		return fmt.Errorf("Couldn't init pacman keyring: %v", err)
	}

	// Setup the trusted keys, by either importing the host's distribution
	// keyrings, or by importing user specified keyrings. Note that these
	// keyrings are accompanied by -trusted files that define the core trusted
	// entities for a distribution.
	var keyrings []string
	if d.ImportedKeyrings != nil {
		keyrings = d.ImportedKeyrings
	} else {
		var err error
		keyrings, err = d.findHostKeyrings(context)
		if err != nil {
			return fmt.Errorf("Unable to find host keyrings: %v", err)
		}
	}
	if len(keyrings) == 0 {
		log.Printf("Warning: failed to identify any trusted keyrings; " +
			"this configuration can only use Siglevel: TrustAll for its repositories")
	} else if err := d.createTrustDb(context, configPath, keyrings); err != nil {
		return fmt.Errorf("Unable to create trustdb: %v", err)
	}

	// Run pacstrap
	cmdline = []string{"pacstrap", "-M", "-C", configPath, context.Rootdir}
	if err := (debos.Command{}.Run("Pacstrap", cmdline...)); err != nil {
		log := path.Join(context.Rootdir, "var/log/pacman.log")
		_ = debos.Command{}.Run("pacstrap.log", "cat", log)
		return err
	}

	if err := d.processPacmanConf(context, filepath.Join(context.Rootdir, "/etc/pacman.conf")); err != nil {
		return err
	}

	// Remove pacstrap config
	os.Remove(configPath)

	return nil
}
